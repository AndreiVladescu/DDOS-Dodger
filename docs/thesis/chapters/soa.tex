\chapter{Background and Related Work}
\label{chap:soa}
In this chapter, we first discuss the security challenges posed by the mass-adoption of IoT devices, then introduce the fundamental concepts behind Moving Target Defence (MTD) and Software-Defined Networking. We conclude this chapter by reviewing existing works in the current literature and state-of-the-art.


\section{Security Challenges in IoT devices}
Studying the current landscape of IoT devices, these can differ in form and function, thus requiring a different approach in how they operate. Such IoT devices often run bare-metal code, a variant of real-time operating systems (RTOS), such as FreeRTOS or VxWorks or even a flavor of embedded Linux distribution, albeit with greatly reduced capabilities and performance compared to a tradional x86. However, all IoT devices have something in common, which is a resource-constrained environment in which they function.

As stated before, IoT devices are heterogenous in their appearance and function, but they are often small devices, with low performance, in terms of CPU power, RAM and storage capacity. More often than not, they don't include displays, and instead rely on other means of interaction, such as a button interface with audio feedback through buzzers, or they implement Bluetooth, WiFi or similar protocols to be used in conjunction with phones. Such a combination of a higher protocol reliance on interaction makes these devices a target for malign actors. Arguably, the most infamous example of IoT devices being attacked and succesfully hacked is the Mirai Botnet\cite{antonakakis2017}.    

The reality which we face is the IoT global landscape contains a plethora of different IoT ecosystems which are not being maintained and secured by their makers, which in turn weakens the security posture of the individuals or companies that use them. What makes them hard to maintain is their differences in operating systems or codebase, since a security update on a smart-bulb from company 'X' will not reduce the security bugs on, let's say, a smart wallplug, made by company 'Y'. The lack of maintenance and constant updates combined with a lack of standardization, the deployment of these limited devices on a global scale and a diverse forms of connectivity makes them prime targets for malign actors.

\section{Moving Target Defence Fundamentals}
The abstract concept of Moving Target Defence (MTD) long predates the modern age-it may even predate written history. One of the most famous uses of this strategic thinking can be seen in ancient China\cite{sawyer2002}, more specifically in the Late Warring States period in China (3rd century B.C.), where the general Li Mu defeated the armies of Bai Qi, by buying more time to raise more levies. He kept his main force on the move in the borderlands, rotating small detachments through several smaller forts, mountain passes and watchtowers, set dummy concentrations of garrisons and put traps to confuse the attackers. This bought him time to raise enough armies to win the war against the Qin State. 

The MTD concept can best be described as the classical "shell-game", where a stone is hidden under three shells or cups, and the gambler tries to guess the location of the stone, after a fast shuffle has occured. The definition of an attack's lifetime can be described with the following formulas:

\begin{align}
\quad & t_{\text{attack}} = t_{\text{probe}} + t_{\text{construct}} + t_{\text{launch}} \label{eq:attack_time} \\
\quad & t_0 + t_{\text{attack}} \in S_{\tau_k} \label{eq:success_condition} \\
\quad & S_{\tau_k} = [t_{\tau_k}, t_{\tau_{k+1}}) \label{eq:service_state}
\end{align}

As shown in equations \ref{eq:attack_time}, \ref{eq:success_condition} and \ref{eq:service_state}\cite{vladescu2025}, the attacker's total time splits into three phases. In \autoref{eq:attack_time}, the attack time is expressed as the sum of periods for proving, constructing the attack and then launching said attack. The successful attack condition is expressed in \autoref{eq:success_condition}, as the starting time, $t_0$, combined with the time to attack, $t_{attack}$, represents the time it took for the attack to launch, during the same state of the service, $S_{\tau_k}$. In \autoref{eq:service_state}, the service state is defined as the extent of time from the period $t_{\tau_k}$ until the next period, $t_{\tau_{k+1}}$.

Moving target defenses have been proposed as a way to make the setting more difficult for the attacker to exploit a vulnerable system, by changing characteristics of said system to present attackers with a varrying attack surface\cite{mtd_vol1}. The ultimate goal of a moving target defense is to increase unpredictability in the target, causing difficulties in delivering an attack to the correct (vulnerable) target.

Examples of MTD already used in modern devices and services include defense stratagems in many layers of computing. Address Space Layout Randomization (ASLR)\cite{shacham2004} and Instruction Set Randomization (ISR)\cite{kc2003} operate in the lowest levels of computing, whereas Honeypots (decoy nodes) and Honeynets (decoy networks) operate at the network level. We can also consider CAPTCHAs as being part of MTD, since bots find it increasingly difficult, even with machine learning (ML) to solve tricky puzzles. All of these strategies imply that the attacker will either miss the target, or worse, hit a decoy node and signal the other defense measures in place.

\section{Software-Defined Networking Fundamentals}

Software-Defined Networking (SDN) is a networking architecture that decouples the control plane - decision making - from the data plane - packet forwarding\cite{feamster2017}. In an SDN architecture, a central controller, which is visible to all network operators, issues flow rules to network switches, based on policies or API calls. This allows a dynamic reconfiguration of forwarding paths without manual(physical) intervention.

SDN uses application programming interface (API) calls, which are a set of standard procedures that define the proper way of communicating beween logical nodes. The control plane is governed by the Northbound API, where upstream applications can control the flows, while the Southbound API is used by the network controller to modify the behaviour of the network switches and routers.

Software-defined networking is used in lots of domains, since networking is a core part of most environments. One use case where it was quickly adopted is in virtualized networks, where a physical network pool of resources is used by separate virtual networks. Other uses include Cloud Computing, by automating the on-demand nature of cloud infrastructure or Content Delivery Networks (CDN).

\section{Related Work}
Research in moving target defence concepts has been conducted by implementing random permutations of resources \cite{al_shaer2013}\cite{jafarian2012}\cite{mtd_vol1} which require the movement to be randomized and take place either in predetermined periodic intervals, making it a pro-active approach, or at unpredictable random times, meaning the approach is proactive.

One notable example of an early MTD strategy for defending networks is Mutable Networks (MUTE) \cite{mtd_vol1}. In MUTE, both IP addresses and port assignments are abstracted from the underlying hosts and bound to entries in a software-defined routing table. At each reconfiguration interval, a cryptographically secure algorithm, driven by private keys, reshuffles these virtual addresses and ports, ensuring that the mapping remains unpredictable and consistently synchronized across all switches. To further disrupt reconnaissance, MUTE transparently alters the way hosts respond to probes, making traditional fingerprinting techniques far less effective. To be able to do this, the mappings are controlled globally by the system, thus making portability into a non-100\% controlled environment not viable.

MacFarland et al. \cite{macfarland2015} describe an SDN‐based anti‐reconnaissance scheme, in which a custom DNS server collaborates with the SDN controller to obscure real host identifiers. When a client issues a DNS query, the controller selects a synthetic IP from its pool and the DNS server returns that address. Simultaneously, NAT rules on the SDN switch translate the fake IP (and a corresponding synthetic MAC) back to the host’s actual MAC and IP. By providing each client with a potentially unique mapping, the system makes it far more difficult for an attacker to reliably enumerate live hosts.

Frequency-hopping\cite{kostic2001} is a method of transmitting data over the air using electromagnetic waves by changing the frequencies at which the data transfer happens. This concept is widely used in electronic warfare (EW) to resist jamming. Luo et al. \cite{luo2015} adapt the frequency‐hopping concept from electronic countermeasures into a network context with their TAP‐based Port and Address Hopping (TPAH) scheme. Operating entirely in user space via a TAP virtual network driver, TPAH periodically rotates both the layer-3 IP addresses and the layer-4 port numbers according to a configurable schedule, thereby disrupting DDoS flooding and port‐scanning attempts.

Random Host Mutation (RHM) \cite{al_shaer2013} continuously assigns short‐lived, randomized IP addresses to hosts. An special device, the MTG gateway, which is based at the network edge, maintains a mapping between these virtual IPs and the hosts’ real IPs, and an MT Controller handles inter‐host communication. Once a session expires, these mappings are eliminated by the controller. However, because each mutation requires updates to the routing table and the address space may become oversubscribed, this approach can introduce significant overhead and latency as the gateway processes frequent, large‐scale routing updates.

Making use of the big addressing space of IPv6, a protection model can be devised, thus making congested IPv4 schemes obsolete. An IPv6, explored and tested approach is Moving Target IPv6 Defense (MT6D)\cite{dunlop2011}, earlier than what the other schemes proposed. This approach is a proactive type, which changes IP address of the sender and receiver periodically during a session - the session is not however interrupted in any way. This protection model makes two implementations available: one is where a host-based embedding is used in software, and the other when it's used inside a gateway device. While the overhead is small, the packet loss does vary depending on the file sizes, since the kernel buffers are used up in the transfers. Latency is also an impediment and the authors believe that re-writing the solution in another low level programming language would solve the problem, as opposed to their Python implementation. Other limitations that are observed include the possibility of colliding IPv6 addresses with other hosts, which, in theory is possible, as the adress space is limited. 

Implementations based on Software-Defined Networking, such as those using the OpenFlow protocol, have also been explored in the literature. One such solution is OpenFlow Random Host Mutation (OF-RHM) \cite{jafarian2012}, which incorporates OpenFlow switches alongside dedicated random host mutation (RHM) gateways and a central SDN controller. In OF-RHM, the SDN controller centrally manages virtual IP translations and updates the flow rules on switches accordingly, maintaining continuous and seamless host-to-host communication. This implementation has been further analyzed and validated under modern scenarios, by using SYN flooding attacks to evaluate effectiveness \cite{rochak2023}. The cited work benchmarks OF-RHM's performance specifically by monitoring CPU usage during DDoS events. The conclusion of these tests is that OF-RHM reduces processor utilization by a large margin when under attack. However, both studies emphasize a critical trade-off: increasing the frequency of IP address mutations enhances security but proportionally raises system overhead.

Another OpenFlow-based solution is proposed by Gudla et al. \cite{gudla2016}, where the authors compare network behavior in scenarios with and without MTD enabled. Their findings indicate that during periods of IP address shuffling the network experiences significant jitter spikes in the MTD scenario, whereas jitter levels remain consistently low without MTD. The increased jitter during shuffling events is attributed to temporary congestion and additional overhead, resulting in a measurable increase in packet loss.

While some earlier MTD strategies primarily rely on rotating the IP addresses of protected assets periodically, another possible approach is to alter the network's configuration based on the specific identity of each client. Changes triggered by client identity can be described as a form of "spatial mutation," in contrast to "temporal mutation," where configurations change periodically with time. An approach that integrates both these spatial and temporal mutation strategies is proposed by Jafarian et al. \cite{jafarian2014}. Through both analytical modeling and practical testing, their study illustrates the effectiveness of combining these mutation strategies in mitigating threats such as reconnaissance, worm infections, and advanced persistent threats (APTs).

To mitigate the overhead typically associated with frequent shuffling in MTD strategies, a streamlined and lower-complexity solution, named SDN-oriented Cost-effective Edge-based MTD Approach (SCEMA)\cite{javadpour2022}, is proposed. This approach prioritizes minimizing deployment and operational costs while preserving or even improving security effectiveness. Evaluated using a Mininet-based setup, SCEMA was shown to effectively enhance unpredictability within the network, significantly raising the attacker's operational costs.